import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:tplaytv/services/api_service.dart';
import 'package:tplaytv/screens/film_screen.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:tplaytv/utils/navigation.dart';
import 'package:shimmer/shimmer.dart';

final customCacheManager = CacheManager(
  Config(
    'recommendedFilmsCache',
    stalePeriod: const Duration(days: 7),
    maxNrOfCacheObjects: 100,
  ),
);

// CategoriesScreen'dan olingan konstantalar
const double kTextBlockHeight = 60.0;
const Color kPinkColor = Color(0xFFFF3B6C);

// CategoriesScreen'dan olingan grid metrikasi
class _GridMetrics {
  final double itemWidth;
  final double itemHeight;
  final double rowHeight;
  final int rowSize;
  final double topPadding;

  const _GridMetrics({
    required this.itemWidth,
    required this.itemHeight,
    required this.rowHeight,
    required this.rowSize,
    required this.topPadding,
  });
}

class RecommendedFilmsScreen extends StatefulWidget {
  const RecommendedFilmsScreen({super.key});

  @override
  State<RecommendedFilmsScreen> createState() => _RecommendedFilmsScreenState();
}

class _RecommendedFilmsScreenState extends State<RecommendedFilmsScreen> {
  // Data
  List<dynamic> _films = [];
  int _selectedFilmIndex = 0;

  // Paging
  int _currentPage = 1;
  final int _perPage = 20;
  bool _isLoading = false;
  bool _hasMore = true;
  String? _errorMessage;

  // Scroll
  final ScrollController _scrollController = ScrollController();
  Timer? _debounce;

  // Focus
  final FocusNode _pageFocusNode = FocusNode();
  final FocusNode _backButtonFocusNode = FocusNode();
  bool _isOnBackButton = false;

  // Layout (CategoriesScreen bilan mos)
  static const double _gridLeftPad = 24.0;
  static const double _gridRightPad = 16.0;
  static const double _horizontalPadding = _gridLeftPad + _gridRightPad; // 40
  static const double _itemMargin = 8.0;
  static const double _gridSpacing = 8.0;
  static const double _targetCards = 5.5;
  static const double _cardRatio = 1.5;
  static const double _rowSpacing = 24.0;

  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

    _fetchFilms(isRefresh: true);
    _scrollController.addListener(_onScroll);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _pageFocusNode.requestFocus();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _debounce?.cancel();
    _pageFocusNode.dispose();
    _backButtonFocusNode.dispose();
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
    super.dispose();
  }

  // -------- Grid metrics (CategoriesScreen'dan) --------

  _GridMetrics _gridMetrics(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - _gridLeftPad - _gridRightPad;

    final maxCrossAxisExtent =
        ((screenWidth - _horizontalPadding - _itemMargin * _targetCards) /
            _targetCards) +
        _itemMargin;

    final rowSize = (availableWidth / maxCrossAxisExtent).floor().clamp(1, 10);
    final itemWidth = (availableWidth - _itemMargin * rowSize) / rowSize;
    final itemHeight = itemWidth * _cardRatio;
    final rowHeight = itemHeight + kTextBlockHeight + _rowSpacing;

    return _GridMetrics(
      itemWidth: itemWidth,
      itemHeight: itemHeight,
      rowHeight: rowHeight,
      rowSize: rowSize,
      topPadding: 24,
    );
  }

  int _rowSizeForWidth() => _gridMetrics(context).rowSize;

  // -------- Fetching --------

  void _onScroll() {
    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 200 &&
        !_isLoading &&
        _hasMore) {
      _debounce?.cancel();
      _debounce = Timer(const Duration(milliseconds: 300), _fetchFilms);
    }
  }

  Future<void> _fetchFilms({bool isRefresh = false}) async {
    if (_isLoading || !mounted) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
      if (isRefresh) {
        _currentPage = 1;
        _hasMore = true;
        _films.clear();
        _selectedFilmIndex = 0;
      }
    });

    try {
      final response = await ApiService.getRecommendedFilms(
        page: _currentPage,
        perPage: _perPage,
      );

      final newFilms = (response['data'] as List<dynamic>?) ?? [];
      final meta = response['meta'] as Map<String, dynamic>?;

      if (!mounted) return;

      setState(() {
        _films.addAll(newFilms);
        _isLoading = false;

        if (meta != null &&
            meta['currentPage'] is int &&
            meta['pageCount'] is int) {
          if (meta['currentPage'] < meta['pageCount']) {
            _hasMore = true;
            _currentPage++;
          } else {
            _hasMore = false;
          }
        } else {
          _hasMore = newFilms.length == _perPage;
          if (_hasMore) _currentPage++;
        }
      });
      _precacheImages(newFilms);
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = "Kontent yuklashda xatolik: $e";
          _showErrorDialog(_errorMessage!);
        });
      }
    }
  }

  void _precacheImages(List<dynamic> films) {
    for (var film in films.take(10)) {
      String coverUrl = 'https://placehold.co/320x180';
      if (film['files'] != null && film['files'].isNotEmpty) {
        final file = film['files'][0];
        if (file['thumbnails'] != null &&
            file['thumbnails']['small'] != null &&
            file['thumbnails']['small']['src'] != null) {
          coverUrl = file['thumbnails']['small']['src'];
        } else if (file['link'] != null) {
          coverUrl = file['link'];
        }
      }
      precacheImage(
        CachedNetworkImageProvider(coverUrl, cacheManager: customCacheManager),
        context,
      );
    }
  }

  Future<void> _onRefresh() async {
    await _fetchFilms(isRefresh: true);
  }

  void _showErrorDialog(String message) {
    if (!mounted) return;
    showDialog(
      context: context,
      builder:
          (context) => AlertDialog(
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
            ),
            title: const Text(
              "Xato",
              style: TextStyle(fontSize: 24, color: Colors.white),
            ),
            content: Text(
              message,
              style: const TextStyle(fontSize: 20, color: Colors.white),
            ),
            backgroundColor: Colors.black.withOpacity(0.8),
            actions: [
              FocusScope(
                child: Builder(
                  builder:
                      (context) => TextButton(
                        onPressed: () => Navigator.pop(context),
                        style: TextButton.styleFrom(
                          backgroundColor:
                              FocusScope.of(context).hasFocus
                                  ? Colors.blue[500]
                                  : Colors.blue[700],
                          padding: const EdgeInsets.symmetric(
                            horizontal: 32,
                            vertical: 16,
                          ),
                        ),
                        child: const Text(
                          "OK",
                          style: TextStyle(fontSize: 20, color: Colors.white),
                        ),
                      ),
                ),
              ),
              FocusScope(
                child: Builder(
                  builder:
                      (context) => TextButton(
                        onPressed: () {
                          Navigator.pop(context);
                          _fetchFilms(isRefresh: true);
                        },
                        style: TextButton.styleFrom(
                          backgroundColor:
                              FocusScope.of(context).hasFocus
                                  ? Colors.blue[500]
                                  : Colors.blue[700],
                          padding: const EdgeInsets.symmetric(
                            horizontal: 32,
                            vertical: 16,
                          ),
                        ),
                        child: const Text(
                          "Qayta urinish",
                          style: TextStyle(fontSize: 20, color: Colors.white),
                        ),
                      ),
                ),
              ),
            ],
          ),
    );
  }

  // -------- Fokus va navigatsiya --------

  KeyEventResult _onKeyEvent(FocusNode node, KeyEvent event) {
    if (event is! KeyDownEvent && event is! KeyRepeatEvent) {
      return KeyEventResult.ignored;
    }

    if (_isOnBackButton) {
      if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
        if (_films.isNotEmpty) {
          setState(() {
            _isOnBackButton = false;
            _selectedFilmIndex = 0;
          });
          _pageFocusNode.requestFocus();
          return KeyEventResult.handled;
        }
      }
      if (event.logicalKey == LogicalKeyboardKey.enter ||
          event.logicalKey == LogicalKeyboardKey.select) {
        Navigator.pop(context);
        return KeyEventResult.handled;
      }
      return KeyEventResult.ignored;
    }

    // Grid (film) fokusida
    final totalFilms = _films.length;
    if (totalFilms == 0) return KeyEventResult.ignored;

    final lastIndex = totalFilms - 1;
    final rowSize = _rowSizeForWidth();

    if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
      if (_selectedFilmIndex < lastIndex) {
        setState(() => _selectedFilmIndex++);
        _scrollToFilmIndex();
      }
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
      if (_selectedFilmIndex > 0) {
        setState(() => _selectedFilmIndex--);
        _scrollToFilmIndex();
      }
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
      final nextRowIdx = _selectedFilmIndex + rowSize;
      if (nextRowIdx < totalFilms) {
        setState(() => _selectedFilmIndex = nextRowIdx);
        _scrollToFilmIndex(force: true);
      } else if (_selectedFilmIndex + 1 <= lastIndex) {
        // Agar pastdagi qatorda elementlar kam bo'lsa, oxirgi elementga o'tish
        setState(() => _selectedFilmIndex = lastIndex);
        _scrollToFilmIndex(force: true);
      } else if (_hasMore && !_isLoading) {
        _fetchFilms();
      }
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.arrowUp) {
      final prevRowIdx = _selectedFilmIndex - rowSize;
      if (prevRowIdx >= 0) {
        setState(() => _selectedFilmIndex = prevRowIdx);
        _scrollToFilmIndex(force: true);
      } else {
        setState(() => _isOnBackButton = true);
        _backButtonFocusNode.requestFocus();
      }
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.enter ||
        event.logicalKey == LogicalKeyboardKey.select) {
      if (_selectedFilmIndex >= 0 && _selectedFilmIndex < _films.length) {
        final film = _films[_selectedFilmIndex];
        final filmId = film['id'];
        Navigator.push(
          context,
          createSlideRoute(FilmScreen(filmId: filmId)),
        ).then((_) => _pageFocusNode.requestFocus());
      }
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  void _scrollToFilmIndex({bool force = false}) {
    if (!_scrollController.hasClients || _films.isEmpty) return;

    final metrics = _gridMetrics(context);
    final targetRow = (_selectedFilmIndex ~/ metrics.rowSize);
    final targetOffset = metrics.topPadding + targetRow * metrics.rowHeight;

    final viewportHeight = _scrollController.position.viewportDimension;
    final currentOffset = _scrollController.offset;

    // Elementning ekran ichida ko'rinishini tekshirish
    final isVisible =
        targetOffset >= currentOffset &&
        (targetOffset + metrics.rowHeight) <= (currentOffset + viewportHeight);

    // Agar 'force' bo'lmasa va element allaqachon ekranda ko'rinib turgan bo'lsa, scroll shart emas
    if (!force && isVisible) {
      return;
    }

    final maxOffset = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxOffset);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOutCubic,
    );
  }

  // -------- UI --------

  Widget _buildSkeletonLoader() {
    final metrics = _gridMetrics(context);
    final itemWidth = metrics.itemWidth;
    final itemHeight = metrics.itemHeight;

    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
        maxCrossAxisExtent: itemWidth + _gridSpacing,
        mainAxisSpacing: _rowSpacing,
        crossAxisSpacing: _gridSpacing,
        childAspectRatio: itemWidth / (itemHeight + kTextBlockHeight),
      ),
      itemCount: 6,
      itemBuilder: (context, index) {
        return Shimmer.fromColors(
          baseColor: Colors.grey[800]!,
          highlightColor: Colors.grey[600]!,
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: Colors.black,
            ),
          ),
        );
      },
    );
  }

  Widget _buildHeader() {
    return InkWell(
      onTap: () => Navigator.pop(context),
      focusNode: _backButtonFocusNode,
      focusColor: Colors.transparent,
      highlightColor: Colors.transparent,
      splashColor: Colors.transparent,
      onFocusChange: (hasFocus) {
        if (hasFocus != _isOnBackButton) {
          setState(() => _isOnBackButton = hasFocus);
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 20),
        color: Colors.transparent,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.arrow_back,
              color: _isOnBackButton ? kPinkColor : Colors.white,
              size: 32,
            ),
            const SizedBox(width: 8),
            Text(
              'Tavsiya etilganlar',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: _isOnBackButton ? kPinkColor : Colors.white,
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final metrics = _gridMetrics(context);
    final itemWidth = metrics.itemWidth;
    final itemHeight = metrics.itemHeight;

    return Scaffold(
      backgroundColor: Colors.black,
      body: Focus(
        autofocus: true,
        focusNode: _pageFocusNode,
        onKeyEvent: _onKeyEvent,
        child: SafeArea(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              Expanded(
                child: RefreshIndicator(
                  onRefresh: _onRefresh,
                  color: Colors.white,
                  child: CustomScrollView(
                    controller: _scrollController,
                    physics: const AlwaysScrollableScrollPhysics(),
                    cacheExtent: 500,
                    slivers: [
                      if (_isLoading && _films.isEmpty)
                        SliverPadding(
                          padding: const EdgeInsets.symmetric(horizontal: 16),
                          sliver: SliverToBoxAdapter(
                            child: _buildSkeletonLoader(),
                          ),
                        ),
                      if (!_isLoading &&
                          _films.isEmpty &&
                          _errorMessage != null)
                        SliverFillRemaining(
                          child: Center(
                            child: Text(
                              _errorMessage!,
                              style: const TextStyle(
                                fontSize: 24,
                                color: Colors.white,
                              ),
                              textAlign: TextAlign.center,
                            ),
                          ),
                        ),
                      if (!_isLoading &&
                          _films.isEmpty &&
                          _errorMessage == null)
                        const SliverFillRemaining(
                          child: Center(
                            child: Text(
                              "Tavsiyalar mavjud emas",
                              style: TextStyle(
                                fontSize: 24,
                                color: Colors.white,
                              ),
                            ),
                          ),
                        ),
                      SliverPadding(
                        padding: const EdgeInsets.fromLTRB(
                          _gridLeftPad,
                          24,
                          _gridRightPad,
                          0,
                        ),
                        sliver: SliverGrid(
                          gridDelegate:
                              SliverGridDelegateWithMaxCrossAxisExtent(
                                maxCrossAxisExtent: itemWidth + _itemMargin,
                                mainAxisSpacing: _rowSpacing,
                                crossAxisSpacing: _itemMargin,
                                childAspectRatio:
                                    itemWidth / (itemHeight + kTextBlockHeight),
                              ),
                          delegate: SliverChildBuilderDelegate((
                            context,
                            index,
                          ) {
                            final film = _films[index];
                            final isSelected =
                                !_isOnBackButton && index == _selectedFilmIndex;
                            return FilmCard(
                              film: film,
                              isSelected: isSelected,
                              onTap: () {
                                Navigator.push(
                                  context,
                                  createSlideRoute(
                                    FilmScreen(filmId: film['id']),
                                  ),
                                ).then((_) => _pageFocusNode.requestFocus());
                              },
                              itemWidth: itemWidth,
                              itemHeight: itemHeight,
                            );
                          }, childCount: _films.length),
                        ),
                      ),
                      if (_isLoading && _films.isNotEmpty)
                        const SliverToBoxAdapter(
                          child: Padding(
                            padding: EdgeInsets.symmetric(vertical: 24.0),
                            child: Center(
                              child: SizedBox(
                                width: 40,
                                height: 40,
                                child: CircularProgressIndicator(
                                  color: kPinkColor,
                                  strokeWidth: 3.0,
                                ),
                              ),
                            ),
                          ),
                        ),
                      if (!_hasMore && _films.isNotEmpty)
                        SliverToBoxAdapter(
                          child: Padding(
                            padding: const EdgeInsets.all(16),
                            child: Center(
                              child: Container(
                                padding: const EdgeInsets.all(12),
                                decoration: BoxDecoration(
                                  color: Colors.black.withOpacity(0.8),
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(
                                    color: Colors.white.withOpacity(0.2),
                                  ),
                                ),
                                child: const Text(
                                  "Barcha tavsiyalar ko‘rsatildi",
                                  style: TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.w500,
                                    color: Colors.white,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// -------- Cards (CategoriesScreen dizayniga mos) --------

class FilmCard extends StatelessWidget {
  final dynamic film;
  final bool isSelected;
  final VoidCallback onTap;
  final double itemWidth;
  final double itemHeight;

  const FilmCard({
    super.key,
    required this.film,
    required this.isSelected,
    required this.onTap,
    required this.itemWidth,
    required this.itemHeight,
  });

  @override
  Widget build(BuildContext context) {
    final files = film['files'] ?? [];
    final imageUrl =
        files.isNotEmpty
            ? (files[0]['thumbnails'] != null &&
                    files[0]['thumbnails']['small'] != null &&
                    files[0]['thumbnails']['small']['src'] != null
                ? files[0]['thumbnails']['small']['src']
                : files[0]['link'] ?? 'https://placehold.co/320x180')
            : 'https://placehold.co/320x180';
    final title = film['name_uz'] ?? 'Noma’lum';
    final year = film['year']?.toString() ?? '';
    final genres = film['genres'] ?? [];
    final genreName = genres.isNotEmpty ? genres[0]['name_uz'] ?? '' : '';

    return GestureDetector(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.fromLTRB(4, 4, 4, 0),
        child: SizedBox(
          width: itemWidth,
          height: itemHeight + kTextBlockHeight,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(
                width: itemWidth,
                height: itemHeight,
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 180),
                  transform: Matrix4.identity()..scale(isSelected ? 1.05 : 1.0),
                  transformAlignment: Alignment.center,
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.4),
                        blurRadius: 15,
                        spreadRadius: 2,
                        offset: const Offset(0, 8),
                      ),
                    ],
                    border:
                        isSelected
                            ? Border.all(color: kPinkColor, width: 2)
                            : null,
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: CachedNetworkImage(
                      imageUrl: imageUrl,
                      cacheManager: customCacheManager,
                      fit: BoxFit.cover,
                      width: itemWidth,
                      height: itemHeight,
                      placeholder:
                          (context, url) =>
                              Container(color: Colors.black.withOpacity(0.8)),
                      errorWidget:
                          (context, url, error) => Container(
                            color: Colors.black.withOpacity(0.8),
                            child: const Icon(
                              Icons.error,
                              color: Colors.white,
                              size: 48,
                            ),
                          ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 4),
                child: Text(
                  title,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 4),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 4),
                child: Text(
                  year.isNotEmpty && genreName.isNotEmpty
                      ? "$year · $genreName"
                      : year.isNotEmpty
                      ? year
                      : genreName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(fontSize: 16, color: Colors.white70),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
