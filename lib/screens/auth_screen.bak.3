import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:tplaytv/services/api_service.dart';
import 'package:tplaytv/main.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'phone_number_formatter.dart';
import 'package:tplaytv/utils/navigation.dart';

// Constants
class AuthConstants {
  static const int codeLength = 4;
  static const int phoneLength = 9; // local length without country code
  static const int timerDuration = 60;
  static const String phonePrefix = '+998';
  static const List<String> validOperatorCodes = [
    '90',
    '91',
    '93',
    '94',
    '95',
    '97',
    '98',
    '99',
    '33',
    '88',
    '50',
    '20',
  ];
}

// Localization strings
class AuthStrings {
  static const String enterCode = "Kodni kiriting";
  static const String enterPhone = "Raqamingizni kiriting";
  static const String submit = "Yuborish";
  static const String confirm = "Tasdiqlash";
  static const String resend = "Qayta yuborish";
  static const String switchToRegister = "Ro'yxatdan o'tishni xohlaysizmi?";
  static const String switchToLogin = "Kirishni xohlaysizmi?";
  static const String fullName = "To'liq ism";
  static const String username = "Foydalanuvchi nomi";
  static const String selectBirthDate = "Tug'ilgan sanani tanlang";
  static const String gender = "Jins";
  static const String male = "Erkak";
  static const String female = "Ayol";
  static const String keyboardHint =
      "Agar raqamli klaviatura ko'rinmasa, qurilma sozlamalarida virtual klaviaturani faollashtiring.";
  static const String errorInvalidPhone = "Noto'g'ri telefon raqami";
  static const String errorCompletePhone = "To'liq raqam kiriting";
  static const String errorCompleteCode = "To'liq kod kiriting";
  static const String errorSendingSms = "SMS yuborishda xatolik yuz berdi";
  static const String errorConfirmingCode = "Kod tasdiqlashda xatolik";
  static const String errorRegistration =
      "Ro'yxatdan o'tishda xatolik yuz berdi";
  static const String errorFillAllFields = "Barcha maydonlarni to'ldiring";
  static const String errorKickDevice = "Qurilma o'chirishda xatolik";
  static const String multipleDevicesTitle = "Bir nechta qurilma topildi";
  static const String multipleDevicesMessage =
      "Bitta qurilmani o'chirib, davom eting:";
}

class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  // Controllers
  final _phoneController = TextEditingController();
  final List<TextEditingController> _codeControllers = List.generate(
    AuthConstants.codeLength,
    (_) => TextEditingController(),
  );
  final _fullNameController = TextEditingController();
  final _usernameController = TextEditingController();

  // Focus nodes
  final _phoneFocusNode = FocusNode(); // TextField focus node
  final _phoneRawFocusNode = FocusNode(); // RawKeyboardListener separate node
  final _submitFocusNode = FocusNode();
  final _switchAuthModeFocusNode = FocusNode();
  final _codeKeyboardFocusNode = FocusNode();
  final List<FocusNode> _codeFocusNodes = List.generate(
    AuthConstants.codeLength,
    (_) => FocusNode(),
  );

  // Keep references to listeners so we can remove them correctly in dispose
  late final List<VoidCallback> _codeFocusListeners = List.generate(
    AuthConstants.codeLength,
    (_) => () {},
  );

  // State variables
  SharedPreferences? _prefs;
  Future<void>? _prefsReady;
  DateTime? _selectedBirthDate;
  bool _isLoginMode = true;
  bool _isCodeSent = false;
  bool _isLoading = false;
  String? _errorMessage;
  int? _selectedGender;
  int _remainingSeconds = AuthConstants.timerDuration;
  Timer? _timer;
  bool _canResend = false;
  bool _isVirtualKeyboardActive = false;

  @override
  void initState() {
    super.initState();
    _prefsReady = _initializePreferences();
    _setupInitialFocus();
    _setupFocusListeners();
  }

  Future<void> _initializePreferences() async {
    _prefs = await SharedPreferences.getInstance();
  }

  void _setupInitialFocus() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _requestFocus(_phoneFocusNode);
        try {
          SystemChannels.textInput.invokeMethod('TextInput.show');
        } catch (_) {}
      }
    });
  }

  void _setupFocusListeners() {
    _phoneFocusNode.addListener(_handlePhoneFocusChange);
    _submitFocusNode.addListener(_handleSubmitFocusChange);
    _switchAuthModeFocusNode.addListener(_handleSwitchAuthFocusChange);

    for (int i = 0; i < _codeFocusNodes.length; i++) {
      // store the exact callback reference so we can remove it later
      _codeFocusListeners[i] = () => _handleCodeFocusChange(i);
      _codeFocusNodes[i].addListener(_codeFocusListeners[i]);
    }
  }

  void _handlePhoneFocusChange() {
    if (_phoneFocusNode.hasFocus) {
      _logDebug("Phone field focused");
      _isVirtualKeyboardActive = true;
      try {
        SystemChannels.textInput.invokeMethod('TextInput.show');
      } catch (_) {}
    } else {
      _isVirtualKeyboardActive = false;
    }
    setState(() {});
  }

  void _handleSubmitFocusChange() {
    if (_submitFocusNode.hasFocus) {
      _logDebug("Submit button focused");
      setState(() {});
    }
  }

  void _handleSwitchAuthFocusChange() {
    if (_switchAuthModeFocusNode.hasFocus) {
      _logDebug("Switch auth mode focused");
      setState(() {});
    }
  }

  void _handleCodeFocusChange(int index) {
    if (_codeFocusNodes[index].hasFocus) {
      _logDebug("Code field $index focused");
      try {
        SystemChannels.textInput.invokeMethod('TextInput.show');
      } catch (_) {}
      setState(() {});
    }
  }

  void _startTimer() {
    _remainingSeconds = AuthConstants.timerDuration;
    _canResend = false;
    _timer?.cancel();

    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }
      if (_remainingSeconds > 0) {
        setState(() => _remainingSeconds--);
      } else {
        setState(() {
          _canResend = true;
          timer.cancel();
        });
      }
    });
  }

  String? _getNormalizedLocalPhone() {
    // Normalize phone input to local 9-digit format (without country code)
    final raw = _phoneController.text.replaceAll(RegExp(r'[^0-9]'), '');
    if (raw.isEmpty) return null;
    if (raw.length == AuthConstants.phoneLength) {
      return raw; // already local 9 digits
    }
    if (raw.length == AuthConstants.phoneLength + 3 && raw.startsWith('998')) {
      // phone given as 998XXXXXXXXX -> strip country code
      return raw.substring(3);
    }
    // potentially user pasted +998... but '+' removed by replaceAll; handle generic:
    if (raw.length > AuthConstants.phoneLength &&
        raw.endsWith(raw.substring(raw.length - AuthConstants.phoneLength))) {
      // fallback — try last 9 digits
      return raw.substring(raw.length - AuthConstants.phoneLength);
    }
    return null;
  }

  bool _isPhoneValid() {
    final local = _getNormalizedLocalPhone();
    if (local == null) return false;
    if (local.length != AuthConstants.phoneLength) return false;
    final operatorCode = local.substring(0, 2);
    return AuthConstants.validOperatorCodes.contains(operatorCode);
  }

  bool _isFormValid() {
    if (_isCodeSent) {
      return _codeControllers.every((c) => c.text.isNotEmpty);
    } else if (_isLoginMode) {
      return _isPhoneValid();
    } else {
      return _isPhoneValid() &&
          _fullNameController.text.trim().isNotEmpty &&
          _usernameController.text.trim().isNotEmpty &&
          _selectedBirthDate != null &&
          _selectedGender != null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          _buildBackground(),
          _buildGradientOverlay(),
          _buildContent(),
        ],
      ),
    );
  }

  Widget _buildBackground() {
    return Container(
      decoration: BoxDecoration(
        image: _tryLoadAssetImage('assets/images/background.png'),
      ),
    );
  }

  Widget _buildGradientOverlay() {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Colors.black.withOpacity(0.3),
            Colors.black.withOpacity(1.0),
          ],
        ),
      ),
    );
  }

  Widget _buildContent() {
    return Center(
      child: SingleChildScrollView(
        padding: const EdgeInsets.only(top: 5, left: 40, right: 40),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            _buildLogo(),
            _buildTitle(),
            const SizedBox(height: 12),
            _buildFormFields(),
            if (_errorMessage != null) _buildErrorMessage(),
            const SizedBox(height: 10),
            _buildSubmitButton(),
            const SizedBox(height: 10),
            if (!_isCodeSent) _buildSwitchAuthModeButton(),
            if (!_isCodeSent) _buildKeyboardHint(),
          ],
        ),
      ),
    );
  }

  Widget _buildLogo() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: _tryLoadAssetImageWidget('assets/images/logo.png', height: 45),
    );
  }

  Widget _buildTitle() {
    return Text(
      _isCodeSent ? AuthStrings.enterCode : AuthStrings.enterPhone,
      style: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
    );
  }

  Widget _buildFormFields() {
    if (_isCodeSent) {
      return _buildCodeInputFields();
    } else if (_isLoginMode) {
      return _buildPhoneField();
    } else {
      return _buildRegistrationFields();
    }
  }

  Widget _buildRegistrationFields() {
    return Column(
      children: [
        _buildPhoneField(),
        const SizedBox(height: 10),
        _buildTextField(
          controller: _fullNameController,
          label: AuthStrings.fullName,
        ),
        const SizedBox(height: 10),
        _buildTextField(
          controller: _usernameController,
          label: AuthStrings.username,
        ),
        const SizedBox(height: 10),
        _buildDatePicker(),
        const SizedBox(height: 10),
        _buildGenderDropdown(),
      ],
    );
  }

  Widget _buildErrorMessage() {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Text(
        _errorMessage!,
        style: const TextStyle(color: Colors.redAccent, fontSize: 10),
        textAlign: TextAlign.center,
      ),
    );
  }

  Widget _buildKeyboardHint() {
    return Padding(
      padding: const EdgeInsets.only(top: 10),
      child: Text(
        AuthStrings.keyboardHint,
        style: TextStyle(color: Colors.white.withOpacity(0.7), fontSize: 9),
        textAlign: TextAlign.center,
      ),
    );
  }

  // Updated phone field: separate RawKeyboardListener focus node
  Widget _buildPhoneField() {
    return RawKeyboardListener(
      focusNode: _phoneRawFocusNode,
      onKey: _handlePhoneKeyboardEvent,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32),
        child: TextField(
          autofocus: true,
          focusNode: _phoneFocusNode,
          controller: _phoneController,
          decoration: InputDecoration(
            prefixIcon: const Icon(Icons.phone, color: Colors.white),
            prefixText: "${AuthConstants.phonePrefix} ",
            prefixStyle: const TextStyle(
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
            hintText: "XX XXX XX XX",
            hintStyle: TextStyle(color: Colors.white.withOpacity(0.5)),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: BorderSide.none,
            ),
            filled: true,
            fillColor: Colors.black.withOpacity(0.5),
            contentPadding: const EdgeInsets.symmetric(
              vertical: 12,
              horizontal: 16,
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: BorderSide(
                color:
                    _phoneFocusNode.hasFocus
                        ? Colors.yellow
                        : Colors.white.withOpacity(0.3),
                width: _phoneFocusNode.hasFocus ? 2 : 1,
              ),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: const BorderSide(color: Colors.yellow, width: 2),
            ),
          ),
          style: const TextStyle(color: Colors.white, fontSize: 12),
          keyboardType: TextInputType.number,
          inputFormatters: [PhoneNumberFormatter()],
          enabled: !_isLoading,
          textInputAction: TextInputAction.done,
          onChanged: (value) {
            setState(() {});
            if (_isPhoneValid()) {
              Future.delayed(const Duration(milliseconds: 300), () {
                if (mounted && _isPhoneValid()) {
                  _requestFocus(_submitFocusNode);
                }
              });
            }
          },
          onEditingComplete: () {
            if (_isPhoneValid()) {
              _requestFocus(_submitFocusNode);
            }
          },
          onSubmitted: (_) {
            if (_isPhoneValid()) {
              _requestFocus(_submitFocusNode);
            }
          },
        ),
      ),
    );
  }

  void _handlePhoneKeyboardEvent(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    final key = event.logicalKey;

    if (key == LogicalKeyboardKey.enter ||
        key == LogicalKeyboardKey.select ||
        key == LogicalKeyboardKey.numpadEnter ||
        key == LogicalKeyboardKey.accept) {
      if (_isPhoneValid()) {
        _requestFocus(_submitFocusNode);
      } else {
        _setError(AuthStrings.errorCompletePhone);
      }
    } else if (key == LogicalKeyboardKey.arrowDown && _isPhoneValid()) {
      _requestFocus(_submitFocusNode);
    }
  }

  Widget _buildCodeInputFields() {
    return Padding(
      padding: const EdgeInsets.only(top: 2),
      child: RawKeyboardListener(
        focusNode: _codeKeyboardFocusNode,
        onKey: _handleCodeKeyboardEvent,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: List.generate(
            AuthConstants.codeLength,
            (i) => _buildCodeField(i),
          ),
        ),
      ),
    );
  }

  void _handleCodeKeyboardEvent(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    final currentFocusIndex = _codeFocusNodes.indexWhere(
      (node) => node.hasFocus,
    );
    if (currentFocusIndex == -1) return;

    final key = event.logicalKey;
    if (key == LogicalKeyboardKey.backspace) {
      _handleBackspaceInCode(currentFocusIndex);
    } else if (key == LogicalKeyboardKey.arrowLeft) {
      _handleArrowLeftInCode(currentFocusIndex);
    } else if (key == LogicalKeyboardKey.arrowRight) {
      _handleArrowRightInCode(currentFocusIndex);
    } else if (key == LogicalKeyboardKey.arrowUp) {
      _requestFocus(_submitFocusNode);
    } else if (key == LogicalKeyboardKey.arrowDown) {
      _requestFocus(_codeFocusNodes[0]);
    } else if (key == LogicalKeyboardKey.enter ||
        key == LogicalKeyboardKey.select ||
        key == LogicalKeyboardKey.numpadEnter) {
      if (_isFormValid()) _requestFocus(_submitFocusNode);
    }
  }

  void _handleBackspaceInCode(int i) {
    if (_codeControllers[i].text.isEmpty && i > 0) {
      _requestFocus(_codeFocusNodes[i - 1]);
    } else {
      // If there's a character, clear it
      _codeControllers[i].clear();
      setState(() {});
    }
  }

  void _handleArrowLeftInCode(int i) =>
      i > 0 ? _requestFocus(_codeFocusNodes[i - 1]) : null;
  void _handleArrowRightInCode(int i) =>
      i < AuthConstants.codeLength - 1
          ? _requestFocus(_codeFocusNodes[i + 1])
          : null;

  Widget _buildCodeField(int index) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: SizedBox(
        width: 50,
        child: TextField(
          focusNode: _codeFocusNodes[index],
          controller: _codeControllers[index],
          decoration: InputDecoration(
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: BorderSide.none,
            ),
            filled: true,
            fillColor: Colors.black.withOpacity(0.5),
            counterText: "",
            contentPadding: const EdgeInsets.symmetric(vertical: 10),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: BorderSide(
                color:
                    _codeFocusNodes[index].hasFocus
                        ? Colors.yellow
                        : Colors.white.withOpacity(0.3),
                width: _codeFocusNodes[index].hasFocus ? 2 : 1,
              ),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: const BorderSide(color: Colors.yellow, width: 2),
            ),
          ),
          style: const TextStyle(color: Colors.white, fontSize: 12),
          keyboardType: TextInputType.number,
          textAlign: TextAlign.center,
          maxLength: 1,
          obscureText:
              false, // show digits — easier for users and for paste handling
          enabled: !_isLoading,
          textInputAction:
              index == AuthConstants.codeLength - 1
                  ? TextInputAction.done
                  : TextInputAction.next,
          onChanged: (v) => _handleCodeFieldChange(index, v),
          onSubmitted:
              (_) =>
                  index == AuthConstants.codeLength - 1 && _isFormValid()
                      ? _requestFocus(_submitFocusNode)
                      : null,
        ),
      ),
    );
  }

  void _handleCodeFieldChange(int index, String value) {
    // Handle paste (value length > 1) by distributing characters into subsequent fields
    if (value.length > 1) {
      _handlePasteInCode(index, value);
      return;
    }

    if (value.isNotEmpty && index < AuthConstants.codeLength - 1) {
      _requestFocus(_codeFocusNodes[index + 1]);
    } else if (value.isEmpty && index > 0) {
      // clear and move back
      _codeControllers[index].clear();
      _requestFocus(_codeFocusNodes[index - 1]);
    }
    if (index == AuthConstants.codeLength - 1 &&
        value.isNotEmpty &&
        _isFormValid()) {
      Future.delayed(const Duration(milliseconds: 300), () {
        if (mounted) _requestFocus(_submitFocusNode);
      });
    }
    setState(() {});
  }

  void _handlePasteInCode(int startIndex, String pasted) {
    final chars = pasted.replaceAll(RegExp(r'[^0-9]'), '').split('');
    if (chars.isEmpty) return;
    int i = startIndex;
    for (var c in chars) {
      if (i >= AuthConstants.codeLength) break;
      _codeControllers[i].text = c;
      i++;
    }
    setState(() {});
    if (i <= AuthConstants.codeLength - 1) {
      _requestFocus(_codeFocusNodes[i]);
    } else {
      // filled all fields
      _requestFocus(_submitFocusNode);
    }
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: TextField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
          labelStyle: const TextStyle(color: Colors.white70, fontSize: 10),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide.none,
          ),
          filled: true,
          fillColor: Colors.black.withOpacity(0.5),
          contentPadding: const EdgeInsets.symmetric(
            vertical: 12,
            horizontal: 16,
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide(
              color:
                  controller.text.isNotEmpty
                      ? Colors.yellow
                      : Colors.white.withOpacity(0.3),
              width: controller.text.isNotEmpty ? 2 : 1,
            ),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.yellow, width: 2),
          ),
        ),
        style: const TextStyle(color: Colors.white, fontSize: 12),
        enabled: !_isLoading,
        textInputAction: TextInputAction.next,
        onChanged: (_) => setState(() {}),
      ),
    );
  }

  Widget _buildDatePicker() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: InkWell(
        onTap: _isLoading ? null : _selectDate,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
          decoration: BoxDecoration(
            border: Border.all(
              color:
                  _selectedBirthDate != null
                      ? Colors.yellow
                      : Colors.white.withOpacity(0.3),
              width: _selectedBirthDate != null ? 2 : 1,
            ),
            borderRadius: BorderRadius.circular(10),
            color: Colors.black.withOpacity(0.5),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                _selectedBirthDate == null
                    ? AuthStrings.selectBirthDate
                    : DateFormat('dd MMMM yyyy').format(_selectedBirthDate!),
                style: TextStyle(
                  color:
                      _selectedBirthDate == null
                          ? Colors.white70
                          : Colors.white,
                  fontSize: 12,
                ),
              ),
              const Icon(Icons.calendar_today, color: Colors.white, size: 18),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _selectDate() async {
    final pickedDate = await showDatePicker(
      context: context,
      initialDate: _selectedBirthDate ?? DateTime(2000),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
      builder:
          (context, child) => Theme(
            data: ThemeData.dark().copyWith(
              colorScheme: const ColorScheme.dark(
                primary: Color(0xFFE91E63),
                onPrimary: Colors.white,
                surface: Colors.black,
                onSurface: Colors.white,
              ),
              dialogTheme: const DialogTheme(backgroundColor: Colors.black),
            ),
            child: child!,
          ),
    );

    if (pickedDate != null && mounted) {
      setState(() => _selectedBirthDate = pickedDate);
    }
  }

  Widget _buildGenderDropdown() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: DropdownButtonFormField<int>(
        value: _selectedGender,
        decoration: InputDecoration(
          labelText: AuthStrings.gender,
          labelStyle: const TextStyle(color: Colors.white70, fontSize: 10),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide.none,
          ),
          filled: true,
          fillColor: Colors.black.withOpacity(0.5),
          contentPadding: const EdgeInsets.symmetric(
            vertical: 12,
            horizontal: 16,
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide(
              color:
                  _selectedGender != null
                      ? Colors.yellow
                      : Colors.white.withOpacity(0.3),
              width: _selectedGender != null ? 2 : 1,
            ),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.yellow, width: 2),
          ),
        ),
        style: const TextStyle(color: Colors.white, fontSize: 12),
        dropdownColor: Colors.black,
        items: const [
          DropdownMenuItem(value: 1, child: Text(AuthStrings.male)),
          DropdownMenuItem(value: 0, child: Text(AuthStrings.female)),
        ],
        onChanged:
            _isLoading ? null : (v) => setState(() => _selectedGender = v),
      ),
    );
  }

  Widget _buildSubmitButton() {
    return Focus(
      focusNode: _submitFocusNode,
      onFocusChange: (_) => setState(() {}),
      onKey: (node, event) {
        if (event is RawKeyDownEvent &&
            (event.logicalKey == LogicalKeyboardKey.select ||
                event.logicalKey == LogicalKeyboardKey.enter) &&
            _isFormValid() &&
            !_isLoading) {
          _handleAction();
          return KeyEventResult.handled;
        }
        return KeyEventResult.ignored;
      },
      child: Container(
        decoration: BoxDecoration(
          border:
              _submitFocusNode.hasFocus
                  ? Border.all(color: Colors.yellow, width: 3)
                  : null,
          borderRadius: BorderRadius.circular(10),
          boxShadow:
              _submitFocusNode.hasFocus
                  ? [
                    BoxShadow(
                      color: Colors.yellow.withOpacity(0.5),
                      blurRadius: 10,
                      spreadRadius: 2,
                    ),
                  ]
                  : null,
        ),
        child: ElevatedButton(
          onPressed: _isFormValid() && !_isLoading ? _handleAction : null,
          style: ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 48, vertical: 12),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
            backgroundColor: const Color(0xFFE91E63),
            disabledBackgroundColor: Colors.grey,
            elevation: 6,
          ),
          child:
              _isLoading
                  ? const SizedBox(
                    width: 18,
                    height: 18,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    ),
                  )
                  : Text(
                    _getSubmitButtonText(),
                    style: const TextStyle(fontSize: 12, color: Colors.white),
                  ),
        ),
      ),
    );
  }

  String _getSubmitButtonText() {
    if (_isCodeSent) {
      if (_canResend) return AuthStrings.resend;
      return "${AuthStrings.confirm} ($_remainingSeconds)";
    }
    return AuthStrings.submit;
  }

  Widget _buildSwitchAuthModeButton() {
    return Focus(
      focusNode: _switchAuthModeFocusNode,
      onFocusChange: (_) => setState(() {}),
      onKey: (node, event) {
        if (event is RawKeyDownEvent &&
            event.logicalKey == LogicalKeyboardKey.select &&
            !_isLoading) {
          _switchAuthMode();
          return KeyEventResult.handled;
        }
        return KeyEventResult.ignored;
      },
      child: Container(
        decoration: BoxDecoration(
          border:
              _switchAuthModeFocusNode.hasFocus
                  ? Border.all(color: Colors.yellow)
                  : null,
          borderRadius: BorderRadius.circular(10),
        ),
        child: TextButton(
          onPressed: _isLoading ? null : _switchAuthMode,
          child: Text(
            _isLoginMode
                ? AuthStrings.switchToRegister
                : AuthStrings.switchToLogin,
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 10,
            ),
          ),
        ),
      ),
    );
  }

  void _switchAuthMode() {
    setState(() {
      _isLoginMode = !_isLoginMode;
      _resetFields();
    });
  }

  Future<void> _handleAction() async {
    if (_isCodeSent) {
      if (_canResend) {
        await _sendPhone();
      } else {
        await _confirmCode();
      }
    } else {
      await _sendPhone();
    }
  }

  Future<void> _sendPhone() async {
    final local = _getNormalizedLocalPhone();
    if (local == null || !_isPhoneValid()) {
      _setError(AuthStrings.errorInvalidPhone);
      return;
    }
    final phone = "998$local"; // normalized to backend format

    _setLoading(true);
    try {
      final result = await ApiService.sendPhone(phone);
      if (!mounted) return;

      if (result) {
        setState(() {
          _isCodeSent = true;
          _errorMessage = null;
        });
        _startTimer();
        _focusFirstCodeField();
      } else {
        _setError(AuthStrings.errorSendingSms);
      }
    } catch (e) {
      _logDebug("Error sending phone: $e");
      if (mounted) _setError("${AuthStrings.errorSendingSms}: $e");
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  void _focusFirstCodeField() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _requestFocus(_codeFocusNodes[0]);
        try {
          SystemChannels.textInput.invokeMethod('TextInput.show');
        } catch (_) {}
        _logDebug("SMS sent, focusing first code field");
      }
    });
  }

  Future<void> _confirmCode() async {
    final code = _codeControllers.map((c) => c.text).join();
    if (code.length != AuthConstants.codeLength) {
      _setError(AuthStrings.errorCompleteCode);
      return;
    }

    _setLoading(true);
    try {
      final result = await ApiService.confirmSms(code);
      if (!mounted) return;

      if (result['success'] == true) {
        _isLoginMode ? _navigateToMainScreen() : await _registerUser();
      } else if (result.containsKey('devices')) {
        await _handleMultipleDevices(result['devices']);
      } else {
        _setError(result['message'] ?? AuthStrings.errorConfirmingCode);
      }
    } catch (e) {
      _logDebug("Error confirming code: $e");
      if (mounted) _setError("${AuthStrings.errorConfirmingCode}: $e");
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  Future<void> _handleMultipleDevices(List<dynamic> devices) async {
    if (devices.isEmpty) return;
    // Ensure preferences are initialized before using token id
    if (_prefsReady != null) await _prefsReady;
    final currentTokenId = _prefs?.getString('token_id');
    final pickedDeviceId = await _showDeviceSelectionDialog(
      devices,
      currentTokenId,
    );
    if (pickedDeviceId != null && pickedDeviceId.isNotEmpty) {
      await _kickDeviceAndContinue(pickedDeviceId);
    }
  }

  // Now returns selected device id (string) or null if cancelled
  Future<String?> _showDeviceSelectionDialog(
    List<dynamic> devices,
    String? currentTokenId,
  ) async {
    if (!mounted) return null;
    final otherDevices =
        devices.where((d) => d['id'].toString() != currentTokenId).toList();
    if (otherDevices.isEmpty) {
      _setError("Qurilmalar ro'yxati bo'sh");
      return null;
    }

    final picked = await showDialog<String?>(
      context: context,
      barrierDismissible: false,
      builder:
          (context) => AlertDialog(
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
            ),
            backgroundColor: Colors.black87,
            title: const Text(
              AuthStrings.multipleDevicesTitle,
              style: TextStyle(color: Colors.white),
            ),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  AuthStrings.multipleDevicesMessage,
                  style: TextStyle(color: Colors.white70),
                ),
                const SizedBox(height: 16),
                ...otherDevices.map((d) => _buildDeviceListTile(d)),
                const SizedBox(height: 8),
                TextButton(
                  onPressed: () {
                    Navigator.pop(context, null);
                  },
                  child: const Text(
                    "Bekor qilish",
                    style: TextStyle(color: Colors.white70),
                  ),
                ),
              ],
            ),
          ),
    );
    return picked;
  }

  Widget _buildDeviceListTile(dynamic device) {
    return Card(
      color: Colors.grey[900],
      margin: const EdgeInsets.symmetric(vertical: 4),
      child: ListTile(
        title: Text(
          device['device_name'] ?? 'Unknown Device',
          style: const TextStyle(color: Colors.white),
        ),
        subtitle: Text(
          "ID: ${device['id']}",
          style: const TextStyle(color: Colors.white60, fontSize: 10),
        ),
        trailing: const Icon(
          Icons.arrow_forward_ios,
          color: Colors.white,
          size: 16,
        ),
        onTap: () {
          // return chosen device id to caller
          Navigator.pop(context, device['id'].toString());
        },
      ),
    );
  }

  Future<void> _kickDeviceAndContinue(String deviceId) async {
    _setLoading(true);
    try {
      final kickResult = await ApiService.kickDevice(deviceId);
      if (!mounted) return;

      if (kickResult) {
        final code = _codeControllers.map((c) => c.text).join();
        final confirmResult = await ApiService.confirmSms(code);
        if (!mounted) return;

        if (confirmResult['success'] == true) {
          _isLoginMode ? _navigateToMainScreen() : await _registerUser();
        } else {
          _setError(AuthStrings.errorConfirmingCode);
        }
      } else {
        _setError(AuthStrings.errorKickDevice);
      }
    } catch (e) {
      _logDebug("Error kicking device: $e");
      if (mounted) _setError("${AuthStrings.errorKickDevice}: $e");
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  Future<void> _registerUser() async {
    // Ensure prefs are loaded
    if (_prefsReady != null) await _prefsReady;

    final fullName = _fullNameController.text.trim();
    final username = _usernameController.text.trim();

    if (fullName.isEmpty ||
        username.isEmpty ||
        _selectedBirthDate == null ||
        _selectedGender == null) {
      _setError(AuthStrings.errorFillAllFields);
      return;
    }

    _setLoading(true);
    try {
      final token = _prefs?.getString('auth_token') ?? '';
      final birthDateUnix =
          (_selectedBirthDate!.millisecondsSinceEpoch ~/ 1000);

      final result = await ApiService.updateUser(
        fullName: fullName,
        username: username,
        birthDate: birthDateUnix,
        sex: _selectedGender!,
        token: token,
      );

      if (!mounted) return;
      result
          ? _navigateToMainScreen()
          : _setError(AuthStrings.errorRegistration);
    } catch (e) {
      _logDebug("Error registering user: $e");
      if (mounted) _setError("${AuthStrings.errorRegistration}: $e");
    } finally {
      if (mounted) _setLoading(false);
    }
  }

  void _navigateToMainScreen() {
    if (!mounted) return;
    Navigator.pushReplacement(context, createSlideRoute(const MainScreen()));
  }

  void _resetFields() {
    _errorMessage = null;
    _phoneController.clear();
    for (var c in _codeControllers) c.clear();
    _fullNameController.clear();
    _usernameController.clear();
    _selectedBirthDate = null;
    _selectedGender = null;
    _isCodeSent = false;
    _remainingSeconds = AuthConstants.timerDuration;
    _canResend = false;
    _timer?.cancel();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _requestFocus(_phoneFocusNode);
        try {
          SystemChannels.textInput.invokeMethod('TextInput.show');
        } catch (_) {}
      }
    });
    setState(() {});
  }

  void _setLoading(bool v) {
    if (!mounted) return;
    setState(() => _isLoading = v);
  }

  void _setError(String e) {
    if (!mounted) return;
    setState(() {
      _errorMessage = e;
      _isLoading = false;
    });
  }

  void _requestFocus(FocusNode node) {
    if (!mounted) return;
    FocusScope.of(context).requestFocus(node);
    try {
      SystemChannels.textInput.invokeMethod('TextInput.show');
    } catch (_) {}
  }

  void _logDebug(String msg) => debugPrint("[AuthScreen] $msg");

  DecorationImage? _tryLoadAssetImage(String path) {
    try {
      return DecorationImage(
        image: AssetImage(path),
        fit: BoxFit.cover,
        opacity: 0.3,
      );
    } catch (e) {
      _logDebug("Failed to load image: $path - $e");
      return null;
    }
  }

  Widget _tryLoadAssetImageWidget(String path, {double? height}) {
    try {
      return Image.asset(path, height: height);
    } catch (e) {
      _logDebug("Failed to load image widget: $path - $e");
      return Container(
        height: height,
        color: Colors.grey[800],
        child: const Center(
          child: Icon(Icons.image_not_supported, color: Colors.white54),
        ),
      );
    }
  }

  @override
  void dispose() {
    _phoneFocusNode.removeListener(_handlePhoneFocusChange);
    _submitFocusNode.removeListener(_handleSubmitFocusChange);
    _switchAuthModeFocusNode.removeListener(_handleSwitchAuthFocusChange);
    for (int i = 0; i < _codeFocusNodes.length; i++) {
      // remove the exact stored listener reference
      _codeFocusNodes[i].removeListener(_codeFocusListeners[i]);
    }

    _phoneFocusNode.dispose();
    _phoneRawFocusNode.dispose();
    _submitFocusNode.dispose();
    _switchAuthModeFocusNode.dispose();
    _codeKeyboardFocusNode.dispose();
    for (var n in _codeFocusNodes) n.dispose();

    _phoneController.dispose();
    for (var c in _codeControllers) c.dispose();
    _fullNameController.dispose();
    _usernameController.dispose();

    _timer?.cancel();
    super.dispose();
  }
}
